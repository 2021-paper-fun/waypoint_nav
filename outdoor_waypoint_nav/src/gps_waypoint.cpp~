#include <ros/ros.h>
#include <move_base_msgs/MoveBaseAction.h>
#include <actionlib/client/simple_action_client.h>
#include <robot_localization/navsat_conversions.h>
#include <geometry_msgs/PointStamped.h>
#include <tf/transform_listener.h>

typedef actionlib::SimpleActionClient<move_base_msgs::MoveBaseAction> MoveBaseClient; //create a type definition for a client called MoveBaseClient

int main(int argc, char** argv)
{
	ros::init(argc, argv, "gps_waypoint"); //initiate node called gps_waypoint
	ROS_INFO("Initiated gps_waypoint node");
	MoveBaseClient ac("move_base", true); //construct an action client that we use to
					      //communication with the action named move_base.
					      //Setting true is telling the constructor to start ros::spin()

        //wait for the action server to come up
        while(!ac.waitForServer(ros::Duration(5.0)))
	{
          ROS_INFO("Waiting for the move_base action server to come up");
        }
	
	double latitude_goal, longitude_goal; //initiate goal variables

	

	move_base_msgs::MoveBaseGoal goal; //initiate a move_base_msg called goal

	tf::TransformListener listener; //create transformlistener object called listener

	//Get Longitude and Latitude goals from the parameter server
	ros::param::get("latitude_goal", latitude_goal);
	ros::param::get("longitude_goal", longitude_goal);
	ROS_INFO("Received Latitude goal:%f", latitude_goal);
	ROS_INFO("Received longitude goal:%f", longitude_goal);

	double utm_x = 0;
	double utm_y = 0;
	std::string utm_zone;

	//Convert Longituded and Latitude to UTM
	RobotLocalization::NavsatConversions::LLtoUTM(latitude_goal, longitude_goal, utm_y, utm_x, utm_zone);
	ROS_INFO("UTM Cord is %f, %f", utm_x, utm_y);

	//Construct UTM_point and map_point geometry messages
	geometry_msgs::PointStamped UTM_point;
	geometry_msgs::PointStamped map_point; 
	
	UTM_point.header.frame_id = "utm" ;
	UTM_point.header.stamp = ros::Time(0) ;
	UTM_point.point.x = utm_x;
	UTM_point.point.y = utm_y;
	UTM_point.point.z = 0;


	//Transform UTM to odom frame
	bool notDone = true;
	ros::Time time_now = ros::Time::now();
	while(notDone)
	{
	    try
	    {
	      UTM_point.header.stamp = ros::Time::now() ;
	      listener.waitForTransform("odom", "utm", time_now, ros::Duration(3.0));
	      listener.transformPoint ("odom", UTM_point, map_point);
	      notDone = false;
	    }
	    catch (tf::TransformException &ex)
	    {
	      ROS_WARN("%s",ex.what());
	      ros::Duration(0.01).sleep();
	    //  return;
	    }
	}

	goal.target_pose.header.frame_id = "odom"; //Specify what frame we want the goal to be published in 
	goal.target_pose.header.stamp = ros::Time::now();

	//Send goal to move_base
	ROS_INFO("Goal in map frame is  %f, %f", map_point.point.x,map_point.point.y);
	goal.target_pose.pose.position.x = map_point.point.x; //specify x goal
	goal.target_pose.pose.position.y = map_point.point.y; //specify y goal
	goal.target_pose.pose.orientation.w = 1.0;	//specify quaternion
	ROS_INFO("Sending goal");
	ac.sendGoal(goal); //push goal to move_base node

	ac.waitForResult(); //waiting to see if move_base was able to reach goal

	if(ac.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
	  ROS_INFO("Husky has reached its goal!");	//here I need to add which waypoint it reached
	else
	  ROS_INFO("Husky was unable to reach its goal. GPS Waypoint unreachable.");

	ros::spin();

	return 0;
}
